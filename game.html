<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StoryPath</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <!-- Theme Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,700;1,400&family=Fredoka:wght@400;700&family=Handlee&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/main.css?v=1763464090">
    <link rel="stylesheet" href="css/game.css?v=1763464090">
    <!-- Splitting.js for character animations -->
    <link rel="stylesheet" href="https://unpkg.com/splitting/dist/splitting.css">
    <!-- Animation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@3.0.0/tsparticles.bundle.min.js"></script>
    <script src="https://unpkg.com/typeit@8.8.7/dist/index.umd.js"></script>
    <script src="https://unpkg.com/splitting/dist/splitting.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/granim@2.0.0/dist/granim.min.js"></script>
    <script src="js/i18n.js?v=1763464090"></script>
</head>
<body>
    <!-- Black screen overlay for theatrical entrance -->
    <div id="theatricalBlack" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10001;"></div>

    <div class="game-container">
        <!-- Header -->
        <header class="game-header">
            <div class="story-title">
                <span class="title-deco">üìñ</span>
                <span id="storyTitleText">Loading...</span>
            </div>
            <div class="header-actions">
                <button class="icon-btn" data-i18n-title="game.menuBtn" title="Menu" onclick="showMenu()">‚öôÔ∏è</button>
                <button class="icon-btn" data-i18n-title="game.historyBtn" title="Story So Far" onclick="showHistory()">üìú</button>
                <button class="icon-btn" data-i18n-title="game.homeBtn" title="Home" onclick="goHome()">üè†</button>
            </div>
        </header>

        <!-- Main Story View -->
        <main class="story-view" id="storyView">
            <!-- Loading indicator (shown initially) -->
            <div class="loading-indicator" id="initialLoading">
                <div class="spinner">‚ú®</div>
                <div data-i18n="game.loading">Loading your story...</div>
            </div>

            <!-- Scene content (hidden initially) -->
            <div class="hidden" id="sceneContent">
                <!-- Scene illustration -->
                <div class="scene-frame">
                    <div class="image-loading-overlay" id="imageLoadingOverlay">
                        <div class="spinner">‚ú®</div>
                        <div class="text">Conjuring scene...</div>
                    </div>
                    <img src="" alt="Scene" class="scene-image" id="sceneImage" onload="imageLoaded()">
                </div>

                <!-- Story text -->
                <div class="narrative-panel">
                    <div class="narrative-text" id="narrativeText">
                        <!-- Story text will be inserted here -->
                    </div>
                </div>

                <!-- Choices -->
                <div class="choices-panel" id="choicesPanel">
                    <!-- Choice buttons will be inserted here -->
                </div>

                <!-- Skeleton loading (replaces thinking overlay) -->
                <div class="skeleton-loading" id="skeletonLoading" style="display: none;">
                    <div class="skeleton-paragraph"></div>
                    <div class="skeleton-paragraph"></div>
                    <div class="skeleton-paragraph short"></div>
                </div>
            </div>
        </main>

        <!-- Stats footer -->
        <footer class="stats-bar" id="statsBar" style="display: none;">
            <div class="stat-item">
                <span class="stat-icon">‚ù§Ô∏è</span>
                <span class="stat-value" id="statHP">100/100</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üéí</span>
                <span class="stat-value" id="statItems">0 items</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">‚≠ê</span>
                <span class="stat-value" id="statKarma">Neutral</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üìñ</span>
                <span class="stat-value">
                    <span data-i18n="game.scene">Scene</span> <span id="statScene">1</span>
                </span>
            </div>
        </footer>
    </div>

    <script>
        const API_URL = `${window.location.protocol}//${window.location.hostname}/storypath-api`;
        const urlParams = new URLSearchParams(window.location.search);
        const storyId = urlParams.get('story');

        let currentStory = null;
        let currentScene = null;
        let currentChoices = null;
        let imageCheckInterval = null;

        // Parse Claude's furigana format: Êº¢Â≠ó„Ää„Åã„Çì„Åò„Äã -> <ruby>Êº¢Â≠ó<rt>„Åã„Çì„Åò</rt></ruby>
        function parseFurigana(text) {
            if (!text) return text;

            // If text already contains HTML ruby tags, Claude generated them directly
            // Remove duplicate kanji„Ääkana„Äã patterns to avoid double furigana
            if (text.includes('<ruby>') || text.includes('<rt>')) {
                // Remove entire kanji„Ääkana„Äã patterns when ruby tags already exist
                // This handles cases like: <ruby>ÁäØ‰∫∫<rt>„ÅØ„Çì„Å´„Çì</rt></ruby>ÁäØ‰∫∫„Ää„ÅØ„Çì„Å´„Çì„Äã
                // or: ÁäØ‰∫∫„Ää„ÅØ„Çì„Å´„Çì„Äã<ruby>ÁäØ‰∫∫<rt>„ÅØ„Çì„Å´„Çì</rt></ruby>
                return text.replace(/([‰∏Ä-ÈæØ„ÄÖ]+)„Ää[„ÅÅ-„Çì]+„Äã/g, '');
            }

            // Convert Êº¢Â≠ó„Ää„Åã„Çì„Åò„Äã format to HTML ruby tags (legacy format)
            return text.replace(/([‰∏Ä-ÈæØ„ÄÖ]+)„Ää([„ÅÅ-„Çì]+)„Äã/g, '<ruby>$1<rt>$2</rt></ruby>');
        }

        function normalizeJapaneseTypography(text) {
            if (!text) return text;

            const jpChar = '[„ÅÅ-„Çñ„Ç°-„É∫‰∏Ä-ÈæØ„ÄÖ„ÄÜ„Éµ„É∂]';
            let normalized = text;

            // Collapse multiple spaces into single space
            normalized = normalized.replace(/\s+/g, ' ');

            // Remove spaces between Japanese characters
            normalized = normalized.replace(new RegExp(`(${jpChar})\\s+(${jpChar})`, 'g'), '$1$2');

            // Fix gaps around dashes/hyphens: remove spaces around them
            // Handle various dash types
            normalized = normalized.replace(/\s*[-‚Äê‚Äë‚Äí‚Äì‚Äî‚Äï]\s*/g, '‚Äî'); // Use em dash, no spaces
            
            // Fix ‰∏Ä (kanji one) used as dash in vertical text - remove spaces around it
            // Only when surrounded by other Japanese characters (not in actual numbers/words)
            normalized = normalized.replace(/([‰∏Ä-ÈæØ„ÅÅ-„Çñ])\s+‰∏Ä\s+([‰∏Ä-ÈæØ„ÅÅ-„Çñ])/g, '$1‚Äî$2');
            normalized = normalized.replace(/([‰∏Ä-ÈæØ„ÅÅ-„Çñ])\s+‰∏Ä([‰∏Ä-ÈæØ„ÅÅ-„Çñ])/g, '$1‚Äî$2');
            normalized = normalized.replace(/([‰∏Ä-ÈæØ„ÅÅ-„Çñ])‰∏Ä\s+([‰∏Ä-ÈæØ„ÅÅ-„Çñ])/g, '$1‚Äî$2');

            // Fix gaps after commas/punctuation: remove space after Japanese punctuation
            normalized = normalized.replace(/([„ÄÅ„ÄÇÔºåÔºé])\s+/g, '$1');

            // Fix gaps before numbers: add zero-width space to allow breaking
            normalized = normalized.replace(new RegExp(`(${jpChar})\\s*([0-9])`, 'g'), '$1\u200b$2');

            // Remove accidental slashes between kana/kanji („Åô/„Çã -> „Åô„Çã)
            normalized = normalized.replace(new RegExp(`(${jpChar})\\/(${jpChar})`, 'g'), '$1$2');

            // Prevent bad line breaks in verbs - add word joiner after suru verbs
            // Match common verb endings like „Åô„Çã, Êù•„Çã, etc.
            normalized = normalized.replace(/([‰∏Ä-ÈæØ]+[„Åô„Åô„Çã])/g, '$1\u2060'); // Word joiner prevents breaks
            normalized = normalized.replace(/([‰∏Ä-ÈæØ]+Êù•„Çã)/g, '$1\u2060');

            return normalized;
        }

        function transformNarrativeText(text) {
            if (!text) return '';
            let transformed = text;

            if (currentStory?.language === 'ja') {
                transformed = normalizeJapaneseTypography(transformed);
                transformed = parseFurigana(transformed);
            }

            return transformed;
        }

        // Load story on page load
        async function loadStory() {
            if (!storyId) {
                alert('No story ID provided');
                window.location.href = '/';
                return;
            }

            try {
                const response = await fetch(`${API_URL}/story/${storyId}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                currentStory = data.story;
                currentScene = data.current_scene;
                currentChoices = data.choices;

                // Apply genre/maturity theme
                if (currentStory && currentStory.genre && currentStory.maturity_level) {
                    const themeClass = `theme-${currentStory.genre}-${currentStory.maturity_level}`;
                    document.body.classList.add(themeClass);
                    console.log('üé® Applied theme:', themeClass);
                }

                // Set language based on story
                if (currentStory && currentStory.language) {
                    setLanguage(currentStory.language);

                    // Apply vertical text for Japanese
                    if (currentStory.language === 'ja') {
                        document.getElementById('storyView').classList.add('ja-vertical');
                        document.body.classList.add('ja-vertical-mode');
                    }
                }

                // Validate data
                if (!currentScene) {
                    throw new Error('No scene data received');
                }

                // Update UI
                updateStoryView();

            } catch (error) {
                console.error('Failed to load story:', error);
                alert('Failed to load story: ' + error.message);
                window.location.href = '/';
            }
        }

        function updateStoryView() {
            // Store scroll position to restore after update
            const scrollY = window.scrollY;
            const scrollX = window.scrollX;

            // Update title (with furigana support)
            document.getElementById('storyTitleText').innerHTML = parseFurigana(currentStory.title);

            // Update narrative
            const narrativeHtml = formatNarrative(currentScene.narrative_text);
            document.getElementById('narrativeText').innerHTML = narrativeHtml;

            // Update image only if URL changed (prevents collapse/flicker on same scene)
            const imageUrl = currentScene.image_url || '/storypath/images/placeholder-scene.png';
            const sceneImage = document.getElementById('sceneImage');
            if (sceneImage.src !== imageUrl) {
                sceneImage.src = imageUrl;
            }

            // Show loading overlay if using placeholder
            if (imageUrl && imageUrl.includes('placeholder')) {
                document.getElementById('imageLoadingOverlay').style.display = 'flex';
                // Start polling for real image
                startImagePolling();
            } else {
                document.getElementById('imageLoadingOverlay').style.display = 'none';
            }

            // Update choices
            updateChoices(currentChoices);

            // Wrap narrative and choices for vertical layout
            if (currentStory.language === 'ja') {
                const narrativePanel = document.querySelector('.narrative-panel');
                const choicesPanel = document.querySelector('.choices-panel');

                // Only wrap if not already wrapped
                if (!narrativePanel.parentElement.classList.contains('vertical-content-wrapper')) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'vertical-content-wrapper';
                    narrativePanel.parentNode.insertBefore(wrapper, narrativePanel);
                    wrapper.appendChild(choicesPanel);
                    wrapper.appendChild(narrativePanel);
                }
            }

            // Update stats
            updateStats();

            // Hide loading, show content
            document.getElementById('initialLoading').classList.add('hidden');
            document.getElementById('sceneContent').classList.remove('hidden');
            document.getElementById('statsBar').style.display = 'flex';

            // Restore scroll position (prevents jumping to top on updates)
            setTimeout(() => {
                window.scrollTo(scrollX, scrollY);
            }, 0);
        }

        function formatNarrative(text) {
            if (!text) return '';
            // Split into paragraphs and wrap in <p> tags
            return text.split(/\n\s*\n/)
                .map(p => {
                    const content = transformNarrativeText(p.trim());
                    return content ? `<p>${content}</p>` : '';
                })
                .join('');
        }

        function updateChoices(choices) {
            const panel = document.getElementById('choicesPanel');
            panel.innerHTML = '';

            if (!choices || !Array.isArray(choices)) {
                console.error('Invalid choices:', choices);
                return;
            }

            choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-button';
                button.setAttribute('data-choice-index', index);
                button.onclick = () => makeChoice(index);

                // Support both database format (choice_text/choice_type) and AI format (text/type)
                const choiceText = choice.choice_text || choice.text || '';
                const choiceType = choice.choice_type || choice.type;
                const emoji = choice.emoji || getDefaultEmoji(choiceType);
                const displayText = transformNarrativeText(choiceText);

                button.innerHTML = `
                    <span class="choice-emoji">${emoji}</span>
                    <span>${displayText}</span>
                `;

                panel.appendChild(button);
            });
        }

        function getDefaultEmoji(type) {
            const emojis = {
                action: '‚öîÔ∏è',
                dialogue: 'üí¨',
                investigate: 'üîç'
            };
            return emojis[type] || '‚ú®';
        }

        async function makeChoice(choiceIndex) {
            // Disable all choices
            document.querySelectorAll('.choice-button').forEach(btn => {
                btn.classList.add('disabled');
            });

            // Hide choices, clear narrative, add skeleton placeholders
            document.getElementById('choicesPanel').style.display = 'none';
            const narrativeText = document.getElementById('narrativeText');
            narrativeText.innerHTML = '';

            // Add 3 skeleton paragraph placeholders
            for (let i = 0; i < 3; i++) {
                const skeleton = document.createElement('div');
                skeleton.className = 'skeleton-paragraph';
                skeleton.dataset.index = i;
                narrativeText.appendChild(skeleton);
            }

            document.querySelector('.narrative-panel').style.display = 'block';

            try {
                const eventSource = new EventSource(`${API_URL}/story/${storyId}/choice?choice_index=${choiceIndex}`);

                let fullNarrative = '';
                let sceneMetadata = null;
                let paragraphIndex = 0;

                eventSource.addEventListener('message', (e) => {
                    console.log('Received SSE:', e.data);
                    const event = JSON.parse(e.data);

                    if (event.type === 'paragraph') {
                        // Find skeleton for this paragraph
                        let skeleton = narrativeText.querySelector(`.skeleton-paragraph[data-index="${paragraphIndex}"]`);

                        if (!skeleton) {
                            // If skeleton doesn't exist, create it (shouldn't happen but fallback)
                            skeleton = document.createElement('div');
                            skeleton.className = 'skeleton-paragraph';
                            skeleton.dataset.index = paragraphIndex;
                            narrativeText.appendChild(skeleton);
                        }

                        // Replace skeleton with actual paragraph
                        const p = document.createElement('p');
                        p.innerHTML = transformNarrativeText(event.text.trim());
                        p.style.opacity = '0';
                        // Use ink-brush animation for Japanese, typewriter for English
                        const isJapanese = currentStory.language === 'ja';
                        p.style.animation = isJapanese
                            ? 'inkBrushReveal 0.6s ease-out forwards'
                            : 'typewriterReveal 0.3s ease-out forwards';

                        skeleton.replaceWith(p);

                        fullNarrative += event.text + '\n\n';
                        paragraphIndex++;

                        // Proactively create skeleton for NEXT paragraph
                        if (!narrativeText.querySelector(`.skeleton-paragraph[data-index="${paragraphIndex}"]`)) {
                            const nextSkeleton = document.createElement('div');
                            nextSkeleton.className = 'skeleton-paragraph';
                            nextSkeleton.dataset.index = paragraphIndex;
                            narrativeText.appendChild(nextSkeleton);
                        }
                    } else if (event.type === 'metadata') {
                        sceneMetadata = event.data;

                        // Remove any remaining skeletons
                        narrativeText.querySelectorAll('.skeleton-paragraph').forEach(s => s.remove());

                        // Close connection
                        eventSource.close();

                        // Update current scene
                        currentScene = {
                            scene_number: sceneMetadata.scene_number,
                            narrative_text: fullNarrative.trim(),
                            image_url: sceneMetadata.image_url
                        };

                        // Store choices
                        currentChoices = sceneMetadata.choices;

                        // Update story state
                        if (sceneMetadata.state_changes) {
                            if (sceneMetadata.state_changes.hp_delta) {
                                currentStory.hp += sceneMetadata.state_changes.hp_delta;
                            }
                        }

                        currentStory.current_scene_number = sceneMetadata.scene_number;

                        // Remove min-height
                        narrativeText.style.minHeight = '';

                        // Show choices and update full view
                        document.getElementById('choicesPanel').style.display = 'flex';
                        updateStoryView();
                    }
                });

                eventSource.addEventListener('error', (e) => {
                    console.error('SSE error:', e);
                    eventSource.close();
                    alert('Failed to process choice. Please try again.');

                    // Re-enable choices
                    document.querySelectorAll('.choice-button').forEach(btn => {
                        btn.classList.remove('disabled');
                    });
                });

            } catch (error) {
                console.error('Failed to process choice:', error);
                alert('Failed to process choice: ' + error.message);

                // Re-enable choices
                document.querySelectorAll('.choice-button').forEach(btn => {
                    btn.classList.remove('disabled');
                });

                document.getElementById('choicesPanel').style.display = 'flex';
            }
        }

        function updateStats() {
            document.getElementById('statHP').textContent = `${currentStory.hp}/${currentStory.max_hp}`;
            document.getElementById('statScene').textContent = currentStory.current_scene_number;

            // Parse stats
            const stats = currentStory.stats ? JSON.parse(currentStory.stats) : {};
            const inventory = currentStory.inventory ? JSON.parse(currentStory.inventory) : [];

            document.getElementById('statItems').textContent = `${inventory.length} ${inventory.length === 1 ? 'item' : 'items'}`;

            // Karma
            const karma = stats.karma || 0;
            let karmaText = 'Neutral';
            if (karma > 30) karmaText = 'Good';
            else if (karma > 60) karmaText = 'Heroic';
            else if (karma < -30) karmaText = 'Dark';
            else if (karma < -60) karmaText = 'Villainous';

            document.getElementById('statKarma').textContent = karmaText;
        }

        function startImagePolling() {
            if (imageCheckInterval) {
                clearInterval(imageCheckInterval);
            }

            imageCheckInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_URL}/story/${storyId}/image/${currentStory.current_scene_number}`);
                    const data = await response.json();

                    if (data.ready && data.url) {
                        document.getElementById('sceneImage').src = data.url;
                        clearInterval(imageCheckInterval);
                    }
                } catch (error) {
                    console.error('Image check failed:', error);
                }
            }, 3000); // Check every 3 seconds
        }

        function imageLoaded() {
            const img = document.getElementById('sceneImage');
            if (!img.src.includes('placeholder')) {
                document.getElementById('imageLoadingOverlay').style.display = 'none';
                if (imageCheckInterval) {
                    clearInterval(imageCheckInterval);
                }
            }
        }

        function showMenu() {
            alert('Menu feature coming soon!');
        }

        function showHistory() {
            window.open(`history.html?story=${storyId}`, '_blank');
        }

        function goHome() {
            if (confirm('Are you sure you want to leave this story?')) {
                window.location.href = 'index.html';
            }
        }

        // Check for curtain reveal on load
        function checkCurtainReveal() {
            console.log('üé≠ Checking for curtain data...');
            const curtainData = sessionStorage.getItem('showCurtain');
            console.log('üé≠ Curtain data found:', curtainData);
            if (curtainData) {
                sessionStorage.removeItem('showCurtain');
                const { genre, maturity } = JSON.parse(curtainData);
                console.log('üé≠ Showing curtain for:', genre, maturity);
                showGameCurtain(genre, maturity);
            } else {
                console.log('üé≠ No curtain data, removing black screen immediately');
                const blackScreen = document.getElementById('theatricalBlack');
                if (blackScreen) blackScreen.remove();
            }
        }

        function showGameCurtain(genre, maturity) {
            // Get genre-appropriate curtain colors
            const curtainColors = {
                fantasy: { kids: ['#ff69b4', '#9c27b0', '#e1bee7'], adult: ['#8b0000', '#ff4500', '#ffd700'] },
                scifi: { kids: ['#00ffff', '#00aaff', '#0088cc'], adult: ['#00ff00', '#00aa00', '#006600'] },
                mystery: { kids: ['#ff9800', '#ffc107', '#ffeb3b'], adult: ['#6c757d', '#495057', '#343a40'] },
                horror: { kids: ['#4a148c', '#6a1b9a', '#8e24aa'], adult: ['#8b0000', '#ff0000', '#4d0000'] },
                adventure: { kids: ['#ffc107', '#ff9800', '#f57c00'], adult: ['#795548', '#6d4c41', '#5d4037'] }
            };

            const colors = curtainColors[genre]?.[maturity] || ['#667eea', '#764ba2', '#f093fb'];

            // Stage lights gradient (from bottom of viewport, pointing up like footlights)
            const stageLightsHTML = `
                <div id="stageLights" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40vh; z-index: 10000; opacity: 0; background: linear-gradient(to top, rgba(255, 215, 0, 0.6) 0%, rgba(255, 215, 0, 0.3) 50%, transparent 100%); pointer-events: none;"></div>
            `;

            // Create curtain overlay (starts closed, invisible)
            const curtainHTML = `
                <div class="curtain-container" data-genre="${genre}" data-maturity="${maturity}" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; opacity: 0;">
                    <div class="curtain-inner">
                        ${[...Array(10)].map(() => '<div class="curtain-strip"></div>').join('')}
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', stageLightsHTML);
            document.body.insertAdjacentHTML('beforeend', curtainHTML);

            const stageLights = document.getElementById('stageLights');
            const curtainContainer = document.querySelector('.curtain-container:last-of-type');
            const strips = curtainContainer.querySelectorAll('.curtain-strip');
            const blackScreen = document.getElementById('theatricalBlack');

            // Apply genre colors to strips
            strips.forEach((strip, i) => {
                const colorIndex = i % colors.length;
                strip.style.background = `repeating-linear-gradient(to left,
                    ${colors[colorIndex]} 4vw,
                    ${colors[(colorIndex + 1) % colors.length]} 8vw,
                    ${colors[(colorIndex + 2) % colors.length]} 10vw)`;
            });

            // Theatrical sequence
            setTimeout(() => {
                console.log('üí° Starting stage lights animation');
                console.log('üí° Stage lights element:', stageLights);
                console.log('üí° Stage lights z-index:', stageLights.style.zIndex);
                // 1. Fade in stage lights
                stageLights.style.transition = 'opacity 0.8s ease-out';
                stageLights.style.opacity = '1';
                console.log('üí° Stage lights opacity set to 1');

                // 2. Quickly fade in curtain (0.4s after lights start)
                setTimeout(() => {
                    curtainContainer.style.transition = 'opacity 0.5s ease-out';
                    curtainContainer.style.opacity = '1';

                    // Remove black screen once curtain is visible
                    setTimeout(() => {
                        if (blackScreen) blackScreen.remove();
                    }, 500);
                }, 400);

                // 3. Open curtain (1.2s after lights start)
                setTimeout(() => {
                    curtainContainer.classList.add('opening');

                    // 4. Fade out stage lights as curtain opens
                    stageLights.style.transition = 'opacity 2s ease-out';
                    stageLights.style.opacity = '0';

                    // Remove curtain and lights after animation completes
                    setTimeout(() => {
                        curtainContainer.remove();
                        stageLights.remove();
                    }, 2500);
                }, 1200);
            }, 100);
        }

        // Load story on page load
        window.addEventListener('load', () => {
            // Check and create curtain FIRST (synchronously) before loading story
            checkCurtainReveal();
            // Then load story content
            loadStory();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (imageCheckInterval) {
                clearInterval(imageCheckInterval);
            }
        });
    </script>
</body>
</html>
